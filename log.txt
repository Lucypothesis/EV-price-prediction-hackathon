240115-pred01: 1.6061374658
- 배터리용량값 결측치 평균으로 채움
- 범주형 변수에 대해 레이블 인코딩을 적용

240115-pred02: 54.7710645129
- 가정: 배터리용량값 결측치 회귀모델 훈련해서 채움
- 상관계수 분석하여
    - train: '보증기간(년)', '가격(백만원)', '주행거리(km)', '차량상태_Pre-Owned'
    - test: '보증기간(년)', '주행거리(km)', '차량상태_Pre-Owned' 
- 결과: 54.7710645129

240116-pred04: 55.1427874689
- 차원이 너무 복잡해져서 오히려 점수가 줄어들었나?
- 가정: 상관계수 낮은 차원 삭제
- 실험: 가격과의 상관계수 계산, LightGBM 기반 변수 중요도 계산 -> 공통 feature 삭제
       공통 항목: ['사고이력', '모델_ID4', '모델_KNE', '구동방식_RWD', '모델_i5', '차량상태_Pre-Owned', '모델_MS', '연식(년)', '모델_iX']
- 결과: 55.1427874689 (???)

240116-pred05: 54.667309255
- 가정: 모두 레이블인코딩을 해보자 (원핫인코딩이 차원을 증가시킨다)
       그리고 배터리용량값 결측치 회귀모델 훈련할 때 train, test feature 통일시킴 ('보증기간(년)', 주행거리(km), '차량상태')
- 결과: 54.667309255 (????) -> 배터리용량값 결측치를 회귀모델 훈련해서 채운 게 문제인 것 같다

240116-pred06: 1.8172457961
- 가정: 배터리용량값 결측치를 전체를 삭제해서 돌려보자
- 결과: 1.8172457961 -> 배터리용량값 결측치는 단순한 방법으로 살려두는 게 맞다

240116-pred07: 1.500101965 !!!!
- 가정: 배터리용량값 결측치를 차량상태별 중앙값으로 채움
- 결과: 1.500101965 -> 차량상태별 중앙값으로 채우는 게 맞았음

240116-pred08: 1.667434377
- 가정: 배터리용량값 결측치를 차량상태별 평균값으로 채움
- 결과: 1.667434377 -> 차량상태별 중앙값으로 채우는 게 베스트

240116-pred09: 1.0876433662 !!!!
- 가정: 학습모델을 decision tree에서 다른거로 바꾸면 점수가 올라갈 것이다
- 실험: DecisionTree, RandomForest, GradientBoosting, LinearRegression, SVR, KNN, LightGBM, CatBoost, XGBoost
       비교 후 제일 성능 좋은 CatBoost(1.3845)로 설정
- 결과: 1.0876433662 -> CatBoost 모델 사용하니 성능이 많이 오름


240117-pred10: 0.9794726483	!!!
- 가정: 없음
- 실험: pred09와 같은 코드로 돌렸더니 LGBM이 RMSE 성능 가장 높게 나와서 이 값으로 제출해봄
- 결과: 0.9794726483	-> 같은 코드라도 돌릴 때마다 모델 성능이 다르게 나오는듯하다.

240118-pred11: 0.9451251291 !!!
- 가정: 세밀한 결측치 처리. 결측치 처리할 때 차량상태와 보증기간(년)의 4분위로 그룹을 나눠서 채우면 점수가 올라갈 것이다.
- 실험: 상관계수 분석 후 차량상태와 보증기간(년)을 고려한 그룹을 생성하기로 함
       중앙값으로 채움
- 결과: 0.9451251291 -> 역시 세밀한 결측치처리가 성능을 높임

240118-pred12: 1.0135202772
- 가정: pred11와 같은 방법이지만 결측치를 중앙값이 아니라 평균값으로 채움
- 결과: 1.0135202772 -> 역시 중앙값으로 채우는 게 잘 된다 (이유는 모름)

240118-pred13: 1.2320645267	
- 가정: pred11와 같은 방법이지만 보증기간(년)의 unique한 값들로 세세하게 그룹화해서 중앙값 채우는 게 성능이 높을 것이다
- 실험: 차량상태와 보증기간(년)의 unique한 값들로 중앙값은 채움
- 결과: 1.2320645267	-> 불확실한 상태에서 결측치를 너무 세세하게 채워버리면 오히려 성능이 떨어지는듯

240118-pred14: 0.9555834927
- 가정: 다른 변수와 상관관계가 낮은 열을 삭제하면 차원이 축소되어 성능이 오를 것이다.
- 실험: 상관관계 분석 후 '사고이력', '연식(년)' 열 삭제함
- 결과: 0.9555834927 -> 상관관계가 낮아도 넣어놓는 것이 좋겠다. 지금은 차원축소가 필요한 상황은 아닌가보다.

240118-pred15: 1.0163864823
- 가정: Optuna로 모델을 설정하고 하이퍼파라미터튜닝을 하면 성능이 오를 것이다.
- 실험: Optuna로 LGBM의 하이퍼파라미터 찾아서 예측값 추출함
- 결과: 1.0163864823 -> 흠 그냥 돌렸을 때가 낫다 ????? 다르게 찾아봐야할듯

250125-pred16: 0.9360308428 !!!
- 생각의 흐름
       Train 데이터 중 Brand New이면서 사고이력 Yes는 무엇인가??
       Test에도 Brand New이면서 사고이력이 Yes인 값들이 있나?
              - 들어있음.. 이것을 어떻게 해석할 것인가
              - Brand New의 정의가 단순히 **공장에서 출고된 새 차량**이 아니라, **판매 전 차량**을 포함할 수 있음
              - 판매 전 차량은 전시, 테스트주행, 운송거리 등으로 인해서 주행거리가 기록될 수 있음
       도메인 지식이 중요하긴 한 것 같다.
- 가정: 파생변수를 추가하면 성능이 오를 것이다.
- 실험: Brand New이면서 사고이력이 Yes인 것에 대한 파생변수를 추가함(BrandNew_Accident)
       사용한 열:
       제조사
       모델
       차량상태
       배터리용량
       구동방식
       주행거리(km)
       보증기간(년)
       사고이력
       연식(년)
       BrandNew_Accident
- 결과: 0.9360308428 -> 일단 지금은 파생변수가 더 필요한 상황임을 알 수 있음

250127-pred17: 0.9360308428
- 가정: 파생변수를 더 추가하면 성능이 오를 것이다.
- 실험: 원핫인코딩 후, 각각의 변수에 대한 상관관계 분석 후 유의미한 파생변수 2개를 추출함
       B_RWD (제조사가 'B사'이고 구동방식이 'RWD'인 것들을 1, 나머지를 0)
- 결과: 0.9360308428 -> B_RWD가 전혀 영향을 미치지 못했다 ..

250127-pred18: 0.9360308428
- 가정: 주행거리(km)을 로그변환하면 성능이 올라갈 것이다.
- 실험: 주행거리(km)에 로그변환 적용함
- 결과: 0.9360308428 -> 찾아보니 트리기반모델(XGBoost, LightGBM, Random Forest 등)은
                       데이터를 자동으로 구간화해서 비선형 관계도 잘 학습한다고 한다.
                       이런 모델에서는 로그 변환으로 데이터를 선형화할 필요가 적기 때문에, 성능이 같게 나올 수 있다.
                    -> 결론: 로그변환은 의미가 없음

250127-pred19: 1.4203338096
- 가정: 파생변수를 더 추가하면 성능이 오를 것이다.
- 실험: 원핫인코딩 후 상관관계 분석을 기반으로 파생변수를 여러 개 생성하여 모델 돌린 후 feature importance 분석하여
       zero-importance인 열들 삭제 후 다시 모델 학습
- 결과: 1.4203338096 -> 열을 더 삭제해야겠다.

250127-pred20: 1.4740281157
- 가정: 파생변수를 더 추가하면 성능이 오를 것이다.
- 실험: 원핫인코딩 후 상관관계 분석을 기반으로 파생변수를 여러 개 생성하여 모델 돌린 후 feature importance 분석하여
       'warranty_per_battery', 'pre_owned_mileage'열 레이블인코딩된 테이블에 붙이고 '사고이력' 없애기
       사용한 열:
       제조사
       모델
       차량상태
       배터리용량
       구동방식
       주행거리(km)
       보증기간(년)
       연식(년)
       BrandNew_Accident
       warranty_per_battery
       pre_owned_mileage
- 결과: 1.4740281157 -> 더 떨어지네.. 흠

250128-pred21: 1.4740281157
- 가정: 제거했던 '사고이력' 변수를 넣으면 성능이 올라갈 것이다.
- 실험: pred20에 사고이력 열 추가하기
- 결과: 1.4740281157 -> 사고이력 열 추가해도 성능이 같다.. 이건 warranty_per_battery랑 pre_owned_mileage를 제거해야 할 듯 하다.

파생변수 조합
       250128-pred22-1: 0.9406395666
       - 가정: 파생변수 조합 조정하면 성능이 오를 것이다. (사고이력 제거)
       - 실험: '제조사', '모델', '차량상태', '배터리용량', '구동방식', '주행거리(km)', '보증기간(년)', '연식(년)', 'BrandNew_Accident'
       - 결과: 0.9406395666 -> 사고이력 빼면 안됨

       250128-pred22-2: 0.9451251291
       - 가정: 파생변수 조합 조정하면 성능이 오를 것이다. (BrandNew_Accident 제거)
       - 실험: '제조사', '모델', '차량상태', '배터리용량', '구동방식', '주행거리(km)', '보증기간(년)', '사고이력', '연식(년)'
       - 결과: 0.9451251291 -> BrandNew_Accident 빼면 안됨

       250128-pred22-3: 0.9834729034
       - 가정: 파생변수 조합 조정하면 성능이 오를 것이다. (구동방식 제거)
       - 실험: '제조사', '모델', '차량상태', '배터리용량', '주행거리(km)', '보증기간(년)', '사고이력', '연식(년)', 'BrandNew_Accident'
       - 결과: 0.9834729034 -> 구동방식 빼면 안됨

250129-pred23-1: 0.9442186478
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 원핫인코딩에서 상관계수가 0.4 이상이지만 레이블인코딩에서 상관계수가 낮은 변수 리스트업
         중복 없이 상관계수가 0.4 이상인 변수     상관계수    label encoding에서의 상관계수   
       제조사_B사           구동방식_RWD     0.651632	        -0.16   
       차량상태_Nearly New  연식(년)        0.596915	        0.10   
       제조사_K사           구동방식_FWD     0.555571	        -0.16   
       모델_KNE            구동방식_FWD     0.501645	        0.21   
       모델_M3             구동방식_RWD     0.483691	        0.21   

       -> 여기중에서 차량상태_Nearly New와 연식(년)을 곱하여 새로운 파생변수 NearlyNew_Year 를 추가함
- 결과: 0.9442186478 -> NearlyNew_Year 추가했더니 성능 더 떨어짐 (필요 x)

250129-pred23-2: 0.9360308428
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: pred23-1에서 리스트업 한 항목 중 제조사_B사와 구동방식_RWD를 동시에 만족하는 행을 1, 아니면 0으로 ComB_RWD 를 추가함
- 결과: 0.9360308428 -> 아무 역할도 하지 못했다. (누적 추가된 파생변수: BrandNew_Accident)

250129-pred23-3: 0.9323327673 !!!
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 제조사_K사와 구동방식_FWD를 동시에 만족하는 행을 1, 아니면 0으로 ComK_FWD 를 추가함
- 결과: 0.9323327673 -> 효과적이었다!!! (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-1: 0.9323327673
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_KNE와 구동방식_FWD를 동시에 만족하는 행을 1, 아니면 0으로 ModKNE_FWD 를 추가함
- 결과: 0.9323327673 -> 아무 영향이 없다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-2: 0.9516196091
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_M3와 구동방식_RWD를 동시에 만족하는 행을 1, 아니면 0으로 ModM3_RWD 를 추가함
- 결과: 0.9516196091 -> 성능이 더 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-3: 0.9323327673
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: - 모델_i5와 구동방식_RWD를 동시에 만족하는 행을 1, 아니면 0으로 ModI5_RWD 를 추가함
- 결과: 0.9323327673 -> 아무 영향이 없다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-4: 0.9323327673
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_iX와 구동방식_RWD를 동시에 만족하는 행을 1, 아니면 0으로 ModIX_RWD 를 추가함
- 결과: 0.9323327673 -> 아무 영향이 없다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-5: 1.0008943253
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_i3와 구동방식_RWD를 동시에 만족하는 행을 1, 아니면 0으로 ModI3_RWD 를 추가함
- 결과: 1.0008943253 -> 성능이 엄청나게 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD)

250129-pred24-6: 0.9322919964 !!!
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_EV6 와 구동방식_FWD 를 동시에 만족하는 행을 1, 아니면 0으로 ModEV6_FWD 를 추가함
- 결과: 0.9322919964 -> 성능이 조금 향상되었다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250129-pred25-1: 0.9478981383
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_Niro 와 구동방식_FWD 를 동시에 만족하는 행을 1, 아니면 0으로 ModNiro_FWD 를 추가함
- 결과: 0.9478981383 -> 성능이 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250129-pred25-2: 0.9915881079	
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 모델_IONIQ 와 구동방식_FWD 를 동시에 만족하는 행을 1, 아니면 0으로 ModIONIQ_FWD 를 추가함
- 결과: 0.9915881079	-> 성능이 훨씬 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250130-pred25-3: 0.971254099
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 보증기간(년) 과 모델_EV6 를 동시에 만족하는 행을 1, 아니면 0으로 Warranty_ModEV6 를 추가함
- 결과: 0.971254099 -> 성능이 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250130-pred26-1: 0.9641931386
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 배터리용량 와 구동방식_FWD 를 곱한 값을 새로운 열 Battery_FWD 로 추가함
- 결과: 0.9641931386 -> 성능이 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250130-pred26-2: 0.9776251909
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 보증기간(년) 과 구동방식_FWD 를 곱한 값을 새로운 열 Warranty_FWD 로 추가함
- 결과: 0.9776251909 -> 성능이 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250130-pred26-3: 0.9699175119
- 가정: 적당한 파생변수를 추가하면 성능이 오를 것이다.
- 실험: 보증기간_구간을 0,1,2,3으로 레이블인코딩함
- 결과: 0.9699175119 -> 성능이 떨어졌다 (누적 추가된 파생변수: BrandNew_Accident, ComK_FWD, ModEV6_FWD)

250130-pred27: 1.0209040676	
- 가정: 예측 모델 가지고 이상치 탐지해서 제거하면 성능이 오를 것이다.
- 실험: 예측 모델에서 95%선 이상치 제거함
- 결과: 1.0209040676	-> 이상치에 중요한 정보가 포함되어 있다. 무작정 제거해버리면 안 된다.

250130-pred28: 0.9624945307
- 가정: 예측 모델 가지고 이상치 탐지해서 제거하면 성능이 오를 것이다.
- 실험: 예측모델에서 99%선 이상치 제거함
- 결과: 0.9624945307 -> 이상치 제거는 좋은 방법이 아니다.

250130-pred29: 1.0901381469
- 가정: 인코딩 방식을 변경하면 성능이 오를 것이다.
- 실험: pred24-6에서 제조사, 모델, 구동방식을 target encoding으로, 차량상태, 사고이력을 label encdoing으로 변경함
       변수: 제조사 모델 차량상태 배터리용량 구동방식 주행거리(km) 보증기간(년) 사고이력 연식(년) BrandNew_Accident ComK_FWD ModEV6_FWD
- 결과: 1.0901381469 -> 이건 아니다..
       XGBoost, LightGBM 같은 트리 기반 모델에서는 Label Encoding이 더 적절한 경우도 많음.
       트리 모델은 범주형 변수를 그대로 분할(Split)하는 방식으로 학습하기 때문에, Target Encoding을 적용하면 연속적인 값으로 변환된 변수를 불필요하게 많은 분할로 학습할 가능성이 있음.
       즉, Label Encoding을 사용하면 트리가 각 범주를 독립적으로 다룰 수 있어서 오히려 성능이 좋아질 수 있음.


- 파생변수 더 추가
- 예측 모델 가지고 이상치 탐지하기